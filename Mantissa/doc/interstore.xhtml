<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Using Mantissa Interstore Messaging</title>
  </head>
  <body>
    <h1>Using Mantissa Interstore Messaging</h1>

    <h2>Why?</h2>

    <p>
      When there is an interaction between two user stores, care must be taken
      or the primary feature provided by Mantissa's division of storage by user
      &mdash; horizontal scalability &mdash; will be disturbed.  If it is
      necessary to interact with data from one user while processing a request
      for another user, interstore messaging provides the APIs for doing so
      which will not interfer with scalability.
    </p>

    <h2>Prerequisites</h2>

    <p>
      Readers should familiarize themselves with the following concepts in
      order to understand all sections of this document:
    </p>

    <ul>
      <li>
        Twisted AMP Commands
      </li>
      <li>
        Axiom Items
      </li>
      <li>
        Mantissa Sharing
      </li>
    </ul>

    <h2>Overview</h2>

    <p>
      As you may have guessed from the title of this document, interaction
      between user stores is done using a <em>message based</em> API.  Instead
      of opening two user stores directly and performing the usual inspection
      and modification of them with Axiom's APIs, applications create messages
      and send them from one store to another.  Messages are defined as AMP
      Command classes.  Applications also define methods to handle and possibly
      respond to these messages.  Methods can also be defined to handle
      successful answers to message or errors generated by some part of the
      message dispatch process.
    </p>

    <p>
      The message delivery system is <em>transactional</em>.  A message which
      is sent in a transaction which is committed is guaranteed to be delivered
      to its recipient.  Similarly, a method which is called to handle a
      received message is called in a transaction; if this transaction fails, a
      persistent record of this failure is created for an administrator to
      examine (in the future, this may also be handled with transparent retry
      or some another strategy to increase reliability).  And again, each
      answer is passed to the method defined to handle it in a transaction with
      similar handling of transaction failures as for message handling methods.
    </p>

    <p>
      In this document, we will consider a simple multi-user appointment
      tracking application which uses the interstore messaging API to establish
      appointments between different users.
    </p>

    <h2>Defining Messages</h2>

    <p>
      Before you can send or receive a message, you first need to define the
      arguments, results, and errors of that message.  This is done with a
      <code class="API">twisted.protocols.amp.Command</code> subclass.  For
      example, here is the definition of <code>MakeAppointment</code>, the
      message the appointment tracking example sends when one user wants to
      make an appointment with another user:
    </p>

    <pre class="python">
class MakeAppointment(Command):
    arguments = [("whom", SenderArgument()), ("when", String())]
    response = [("appointmentID", Unicode())]
    errors = {"busy": Busy}
    </pre>

    <h2>Receiving Messages</h2>

    <h3>Addressing</h3>

    <p>
      The Mantissa sharing system is used to specify the target of an
      interstore message.  Targets are specified as instances of <code
      class="API">xmantissa.sharing.Identifier</code>.  These instances
      identify an <code>Item</code> instance in a particular user's store by
      its <code>shareID</code>.  To receive a message, these items must be
      shared to the sender using the <code
      class="API">xmantissa.ixmantissa.IMessageReceiver</code> interface.
    </p>

    <h3>Method Dispatch</h3>

    <p>
      The simplest way to handle interstore messages is to use the <code
      class="API">xmantissa.interstore.AMPReceiver</code> mixin.  Once a
      message gets to an item, if that item's class mixes in
      <code>AMPReceiver</code>, the message will be dispatched to a method
      based on the command in the message.  These methods are defined similarly
      to normal AMP command responders, but using the <code
      class="API">xmantissa.interstore.commandMethod</code>, <code
      class="API">xmantissa.interstore.answerMethod</code>, and <code
      class="API">xmantissa.interstore.errorMethod</code> exposers.
    </p>

    <p>
      In the example appointment tracking application, the
      <code>Calendar</code> class's <code>peerRequestedAppointment</code>
      method shows how <code>commandMethod</code> can be used.
    </p>

    <pre class="python">
@commandMethod.expose(MakeAppointment)
def peerRequestedAppointment(self, whom, when):
    app = Appointment(
        store=self.store, when=Time.fromISO8601TimeAndDate(when),
        withWhomUsername=whom.localpart, withWhomDomain=whom.domain,
        withWhomShareID=whom.shareID, remoteID=whom.shareID)
    role = getPrimaryRole(self.store, u"%s@%s" % (whom.localpart, whom.domain), True)
    appointmentID = role.shareItem(app, interfaces=[IMessageReceiver]).shareID
    return {'appointmentID': appointmentID}
</pre>

    <h2>Sending Messages</h2>

    <p>
      As <code>AMPReceiver</code> provides a relatively high-level API for
      receiving messages, <code
      class="API">xmantissa.interstore.AMPMessenger</code> provides a
      high-level API for sending messages.  <code>AMPMessenger</code> instances
      are ephemeral, intended to be created as necessary to send messages.
      However, to create one, a <code
      class="API">xmantissa.interstore.MessageQueue</code> is required.  Aside
      from that, two <code>Identifier</code> instances, a sender an a target,
      are also needed.  Once created, an <code>AMPMessenger</code> instance's
      <code class="API">xmantissa.interstore.AMPMessenger.messageRemote</code>
      method may be used to send a message.  This method takes an AMP
      <code>Command</code> subclass, any keyword arguments allowed by that
      <code>Command</code> and optionally a <em>consequence</em>.
    </p>

    <p>
      An example of this can be seen in the example's
      <code>Calendar.requestAppointmentWith</code> method.  This is the method
      invoked by other application code (in the case of the example, by the web
      user interface code) to try to create a new appointment.
    </p>

    <pre class="python">
def requestAppointmentWith(self, whom, when):
    appointment = Appointment(
        store=self.store, when=when, withWhomShareID=whom.shareID,
        withWhomUsername=whom.localpart, withWhomDomain=whom.domain)
    role = getPrimaryRole(self.store, u"%s@%s" % (whom.localpart, whom.domain), True)
    appointmentID = role.shareItem(appointment, interfaces=[IMessageReceiver]).shareID

    messenger = AMPMessenger(
        self.messageQueue,
        Identifier(appointmentID, *getAccountNames(self.store).next()),
        whom)
    messenger.messageRemote(
        MakeAppointment, appointment, when=when.asISO8601TimeAndDate())
    </pre>

    <h3>Consequences</h3>

    <p>
      If a consequence item is supplied to a <code>messageRemote</code> call,
      that item will be used to look up a handler for the response to the
      message, or a handler for any error which occurs while delivering that
      message.
    </p>

    <p>
      The appointment tracking example uses consequences to make the result of
      any appointment setup attempt go to an instance of
      <code>Appointment</code> which locally represents that potential
      appointment.  This lets it adjust local state easily to reflect either
      successful appointment setup or any errors.  This is implemented using
      the <code>answerMethod</code> and <code>errorMethod</code> exposers:
    </p>

    <pre class="python">
@answerMethod.expose(MakeAppointment)
def appointmentMade(self, appointmentID):
    self.remoteID = appointmentID
    print 'Appointment made'


@errorMethod.expose(MakeAppointment, Busy)
def appointmentFailed(self, failure):
    self.failed = u"Appointment not made, too busy."
    </pre>

    <h2>Conclusion</h2>

    <p>
      What you've learned here, about <code>AMPReceiver</code>,
      <code>AMPMessenger</code>, and the command, answer, and error method
      exposers, should let you write applications with interactions between
      multiple users in a way which preserves Mantissa's horizontal scalability
      features.
    </p>

    <p>
      See the full appointment tracking example source here:
    </p>

    <ul>
      <li><a href="listings/interstore/cal.py">cal.py</a> - The application
      model, including all of the interstore messaging code.</li>

      <li><a href="listings/interstore/webcal.py">webcal.py</a> - The web
      interface for the application.</li>

      <li><a href="listings/interstore/xmantissa/plugins/calendar_offering.py">
      xmantissa/plugins/calendar_offering.py</a> - The dropin which makes the
      appointment tracking application available for inclusion in a Mantissa
      product.</li>
    </ul>

    <p>
      This example is fully runnable.  Just add it to your <code
      class="shell">PYTHONPATH</code> and start Mantissa server.  It provides a
      <em>Calendar</em> offering which includes one installable powerup.
    </p>

  </body>
</html>
